 [![Creative Commons License BY-SA 4.0 International](https://i.creativecommons.org/l/by-sa/4.0/80x15.png)](../LICENSE_OUTLINE.md "プラグインのライセンスについて")

# Qithub のプラグインについて

Qithub （以下本体スクリプト）はプラグイン機能を持っています。これは Qiita ユーザーのコラボレーションの１つとして**プログラム言語に依存しないで Qithub で遊ぶために用意されたもの**で、GitHub アカウントを持っている **[Qiitadon](https://qiitadon.com) ユーザーなら誰でも作成・参加できます**。

## どうやって使うの？

Qithub プラグインは２通りの実行方法があります。

1. Mastodon のトゥート経由（対応中）
2. REST API 経由（完了）

### Mastodon のトゥート経由でのプラグイン実行

Qithubのアカウント（`@qithub@qiitadon.com`）をフォローし、以下のフォーマットでメンション（ユーザー名付きトゥート）をすると、処理結果が返信トゥートされます。

    @qithub:<プラグイン名>␣<プラグイン引数>

#### トゥート例

- `@qithub:roll-dice 3d5`
    - `rolld-dice` プラグインに引数 `3d5` が渡され５面のサイコロを３回振った結果が返信トゥートされます。
- `@qithub:roll-dice --help`<br>`@qithub:roll-dice --version`
    - `rolld-dice` プラグインに `--<key>` 付きの引数を渡すと、プラグインのディレクトリ内に設置された `info.json` に記載された配列の `<key>` キーの値が返信トゥートされます。この場合は `help` キーと `version` キーの値が返信トゥートされてきます。
- `@qithub:help`
    - `help` プラグインが呼び出され、プラグインの使い方が返信トゥートされます。
- `@qithub:go:say-hello-world`
    - `say-hello-world` プラグインが `golang` で実行され、"Hello World" が返信トゥートされます。（プラグインの本体 `main.xxx` が複数の言語で書かれていた場合に指定可能）

- `@qithub:echo Hello World !!!`
    - `echo` プラグインに引数 `Hello World !!!` が渡され、おうむ返しのトゥートが返信されます。

- プラグイン名以降〜トゥートの最後までの文字列は引数としてプラグインに渡されます。

	```
	@qithub:pl:echo これは複数行のトゥートです。
	２行目 `age`
	```

	プラグインが受け取る内容（）
	``&pg_lang="pl"&args="これは複数行のトゥートです。\n２行目 `age`"``

### シェルのコマンド実行とは違うの？

Mastodon のトゥートによるコマンド実行と言っていいかもしれません。`nslookup` というプラグインを作って `nslookup` コマンドと同じ動作をするようなスクリプトを書いても面白いかもしれません。

## どんなプラグインを作ればいいの？

[禁止事項](#禁止事項)に触れなければ**特に設けていません**。[[禁止事項をみる](#禁止事項)]

先を越されていなければ「Hello world」を返すだけのようなプラグインでも大丈夫です。先を越されていた場合は、そのプラグインを整備（コメント付け、誤字修正、リファクタリング）したり、機能を拡張したり、同じ機能を別言語で実装してみるなど、色々チャレンジしてみて遊んでください。

また、issue「[機能拡張 なくてもいいけど、あるとよりよい機能は？](https://github.com/Qithub-BOT/items/issues/14)」を参考にしたり、そこでアイデアを募ってもいいかもしれません。


# プラグインの基本概要

## Qithub エンコードとは

> JSON 形式の文字列を URL エンコードした１文字列のこと。

Qithub では、本体スクリプト（ `Qithub-BOT/index.php` ）とプラグイン（ `Qithub-BOT/scripts/plugins/` ）間は、この Qithub エンコードされた１つの文字列でデータの送受を行います。

## データの受け取り（INPUT/REQUEST）

- プラグインは本体スクリプトから CLI 経由で呼び出し（実行）されます
- プラグインが必要なデータは、本体スクリプトからの呼び出し（実行）時の**第１引数に Qithub エンコードされた文字列で渡されます**

そのため、プラグインは以下の処理が必須となります。

1. スクリプトの第１引数の文字列の取得 = Qithub エンコードされたデータの受け取り
2. 取得した Qithub エンコード文字列の URL デコード = JSON文字列へ変換

なお、受け取った JSON 文字列を内部処理用に配列やオブジェクトへ変換するのは、各ユーザー・スクリプトの自由です。

## 受け取るデータの中身

以下の JSON 文字列データ（Qithub エンコードされたデータ）が渡されます

```
{
    "name_plugin": "<呼び出されたプラグイン名>",
    "mode": "<デバッグモードでの呼び出しの場合は `debug`>",
    "args": "<プラグイン引数>",
    "callback": array
}
```

"callback" キーの配列は、プラグインの設定ファイル `info.json` に要求（他のプラグインの実行結果やアクセストークンのリクエスト）が記載されていた場合に、その内容が付加される。


## 処理結果の差し出し（OUTPUT/RESPONSE）

プラグインは処理の結果と内容を、以下の JSON 配列の文字列に代入し URL エンコードした文字列として標準出力します。

```
{
    "result": "[your_status]",
    "value": "[your_contents]"
}
```

|キー名|値の形式|概要|説明|
|:--- | :---: | :--- | :--- |
| `result` | string | 処理結果 | "OK" / "NG" のいずれかの文字列。ユーザー・スクリプト内の処理が正常に行われた場合は "OK" にすること。|
| `value`  | string | 処理内容 | "result" のステータスが "NG" の場合は、そのエラー内容。"OK" の場合は、処理結果の値を返します。JSON形式 か文字列かは各ユーザー・スクリプトの仕様によります。各スクリプトの README.md もしくは main スクリプト内に明記すること。|

## どこに作ればいいの？

プラグインの設置先は [`scripts` リポジトリ](https://github.com/Qithub-BOT/scripts)内の `plugins` ディレクトリ下に自分のプラグイン名のディレクトリを作成し、`main.xx`（xxはプログラムの拡張子）を設置します。

## どうやって作ればいいの？

`scripts`リポジトリを自分のローカルにクローンしてブランチを切り、そこにプラグインをコミットしたら、`Pull Request` を送りマージ依頼をする。テストにパスしたら完了！

### どういうこと？

- `scripts`リポジトリを `git`（コマンド or アプリ）を使って自分のローカルにクローン
- 作業用のブランチを切る（作成する）
- プラグインを作成・修正する
- 作成したプラグインを (2) で作成したブランチにコミット（登録）する
- 作成が終わったら、Origin（クローン元）に `Pull Request` を送りマージの依頼をする
- 自動コードレビューが行われ、パスしたらマージが行われる
- マージが無事行われたらブランチは削除されます

### ?? Git?

- GitHub でコラボをするうえで必須のアプリ
- [Git](https://qiita.com/search?q=git%E3%81%A8%E3%81%AF) と [GitHub Desktop](https://qiita.com/search?q=GitHub+Desktop) で検索してみよう

# プラグインの仕様

## プログラム言語

サーバーが対応している CLI で動作する言語であれば**開発言語は問いません**

- PHP/HHVM
- GoLang
- Python
- Node.js
- Perl

## プラグインの命名ルール（ディレクトリ名）
    - [DO]-[WHAT]-[WHERE] の順でお願いします。
        - 例）"say-hello", "roll-dice", "get-link-text", "search-string-wikipedia"

- プラグイン本体のスクリプト名
    - 呼び出されるプラグイン本体は "main.xxx" であること（xxxはプログラム言語ごとの拡張子）
    - プラグイン本体以外のスクリプト名には特にルールはありませんが、プラグイン・ディレクトリ内での方言や記述ルールは統一するようにしてください

- 設置先
    - `scripts/plugins/<プラグイン名>/main.xxx`

    - 必須ファイル（プラグイン・ディレクトリに設置するファイル）
        - `main.xxx` ：プラグイン本体
        - `index.html`：ブランク・ファイル

    - オプション・ファイル（あるといいもの）
        - `README.md`：プラグインの使い方や仕様などを記載します。（プラグイン本体に明記されていれば不要）
        - `.gitignore`：プラグインがファイルやデータを作成・保存する場合、それらデータをリポジトリに同期しないように設置します。


# 注意事項

## 「Side CI」のチェックがあります

作成したプラグインを Qithub-BOT/scripts リポジトリにプルリクエスト（以下 PR）すると SideCI によるコードレビューが自動的に行われますので、最低限このチェックをパスする必要があります。

## 書いたスクリプトは修正されます

Qithub-BOT/scripts に Push された、ブランチ／PR／コミットは**コードレビューを通った早いもの勝ち**でマージされます。また、自身が PR したブランチに他のユーザーがコミットすることもあります。

## ブランチは削除されます

マージ後、当該ブランチはマージ担当者によって削除されます。

## 禁止事項

- 遊びではなく**イタズラや悪意のある目的の実装**は禁止
- 自身のプラグイン・**ディレクトリより外へのファイル作成**は禁止
- 自身のプラグイン・**ディレクトリより外へのデータ・アクセス**は禁止（Web APIなどへのアクセスを除く）
- パスワードやアクセストークンなどの**非公開情報をハードコーディングしないと動作しない**実装は禁止
- **アクセストークンなどを使う処理**は禁止 [^1](#脚注)
- Qithub のライセンス（CC BY-SA）とは**違うライセンスのスクリプトを含める**ことは禁止[^2](#脚注)
- Qiita / Qiitadon 含む、**サービスやユーザーに迷惑をかける**ことが明確な実装は禁止

## 脚注 <a name="脚注">

1.  トゥートや Qiita記事の投稿など **特定ユーザーのアカウントで操作が必要なもの**。これらの操作が必要な機能を作りたい場合は`plugins`でなく`system`ディレクトリに設置する必要がありますが、その場合は、まず issue をたてて相談してください。
2.  プラグインの実行時に自身のプラグイン・**ディレクトリにダウンロードして利用する場合はこの限りではありません**が、ダウンロード先のスクリプトが安全- Qiita / Qiitadon 含む**サービスやユーザーに迷惑をかける**ことが明確な実装は禁止
